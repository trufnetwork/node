---
name: Build AMI

# This workflow should be triggered MANUALLY when AMI infrastructure needs updating.
# Node software updates are handled automatically via Docker :latest tag.
#
# When to rebuild AMI:
#   ‚úÖ Infrastructure changes (scripts, services, docker-compose)
#   ‚úÖ Base OS updates (Ubuntu patches)
#   ‚úÖ AWS Marketplace submission
#   ‚úÖ Major version releases
#
# When NOT to rebuild:
#   ‚ùå Regular node software updates (use Docker image workflow instead)
#   ‚ùå Bug fixes (users get them via :latest tag)

'on':
  workflow_dispatch:
    inputs:
      stage:
        description: "Deployment stage (prod or dev)"
        type: choice
        options:
          - prod
          - dev
        default: prod
      reason:
        description: "Reason for AMI rebuild (e.g., 'infrastructure update', 'marketplace submission')"
        type: string
        required: false

permissions:
  contents: write  # For updating release descriptions with AMI details
  id-token: write  # For AWS OIDC authentication

env:
  AWS_REGION: us-east-2

jobs:
  build-ami:
    name: Build TrufNetwork AMI
    runs-on: ubuntu-latest
    env:
      STAGE: ${{ inputs.stage || 'prod' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get latest release version
        id: get-version
        run: |
          # Get latest release tag from GitHub API
          LATEST_VERSION=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
          if [ -z "$LATEST_VERSION" ]; then
            LATEST_VERSION="manual"
          fi
          echo "Latest release version: $LATEST_VERSION"
          echo "version=$LATEST_VERSION" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.x'
          check-latest: true

      - name: Install AWS CDK
        run: |
          npm install -g aws-cdk@latest
          cdk --version

      - name: Deploy/Update AMI pipeline infrastructure
        run: |
          cd deployments/infra
          echo "Destroying existing AMI pipeline to ensure fresh components..."

          # Destroy existing stack (ignore errors if it doesn't exist)
          cdk destroy AMI-Pipeline-${{ env.STAGE }}-Stack \
            --app "go run ami-cdk.go" \
            --context stage=${{ env.STAGE }} \
            --force || echo "Stack didn't exist or failed to destroy, continuing..."

          echo "Deploying fresh AMI pipeline infrastructure for stage: ${{ env.STAGE }}..."
          echo "This ensures all components use the latest code from this repository."

          cdk bootstrap --app "go run ami-cdk.go" --require-approval never
          cdk deploy AMI-Pipeline-${{ env.STAGE }}-Stack \
            --app "go run ami-cdk.go" \
            --context stage=${{ env.STAGE }} \
            --require-approval never

          # Get pipeline ARN after deployment
          PIPELINE_ARN=$(aws cloudformation describe-stacks \
            --stack-name "AMI-Pipeline-${{ env.STAGE }}-Stack" \
            --region "${{ env.AWS_REGION }}" \
            --query \
              "Stacks[0].Outputs[?OutputKey==\`AmiPipelineArnOutput\`].OutputValue" \
            --output text)
          echo "PIPELINE_ARN=$PIPELINE_ARN" >> "$GITHUB_ENV"

      - name: Trigger AMI build
        env:
          BUILD_REASON: ${{ inputs.reason || 'Manual trigger' }}
        run: |
          if [ -z "${PIPELINE_ARN:-}" ]; then
            echo "PIPELINE_ARN is empty; aborting." >&2
            exit 1
          fi

          echo "üöÄ Starting AMI build with pipeline: $PIPELINE_ARN"
          echo "üìù Reason: $BUILD_REASON"
          echo "üè∑Ô∏è  Stage: ${{ env.STAGE }}"

          # Start image pipeline execution
          EXECUTION_ID=$(aws imagebuilder start-image-pipeline-execution \
            --image-pipeline-arn "$PIPELINE_ARN" \
            --region "${{ env.AWS_REGION }}" \
            --query 'imageBuildVersionArn' \
            --output text)

          echo "AMI build started with execution ID: $EXECUTION_ID"
          echo "EXECUTION_ID=$EXECUTION_ID" >> "$GITHUB_ENV"

      - name: Wait for AMI build completion
        timeout-minutes: 90
        run: |
          echo "Waiting for AMI build to complete..."
          echo "Execution ID: $EXECUTION_ID"

          # Poll for completion
          while true; do
            STATUS=$(aws imagebuilder get-image \
              --image-build-version-arn "$EXECUTION_ID" \
              --region "${{ env.AWS_REGION }}" \
              --query 'image.state.status' \
              --output text)

            echo "Current status: $STATUS"

            case $STATUS in
              "AVAILABLE")
                echo "‚úÖ AMI build completed successfully!"

                # Get AMI ID
                AMI_ID=$(aws imagebuilder get-image \
                  --image-build-version-arn "$EXECUTION_ID" \
                  --region "${{ env.AWS_REGION }}" \
                  --query 'image.outputResources.amis[0].image' \
                  --output text)

                echo "AMI ID: $AMI_ID"
                echo "AMI_ID=$AMI_ID" >> "$GITHUB_ENV"
                break
                ;;
              "FAILED")
                echo "‚ùå AMI build failed!"
                exit 1
                ;;
              "CANCELLED")
                echo "‚ùå AMI build was cancelled!"
                exit 1
                ;;
              *)
                echo "‚è≥ Build in progress... waiting 30 seconds"
                sleep 30
                ;;
            esac
          done

      - name: Get AMI details
        run: |
          if [ -n "$AMI_ID" ]; then
            echo "üìã AMI Build Summary:"
            echo "AMI ID: $AMI_ID"
            echo "Region: ${{ env.AWS_REGION }}"
            echo "Pipeline ARN: $PIPELINE_ARN"
            echo "Execution ID: $EXECUTION_ID"

            # Get AMI details
            aws ec2 describe-images \
              --image-ids "$AMI_ID" \
              --region "${{ env.AWS_REGION }}" \
              --query \
                'Images[0].{Name:Name,Description:Description,CreationDate:CreationDate,VirtualizationType:VirtualizationType,Architecture:Architecture,RootDeviceType:RootDeviceType}' \
              --output table
          fi

      - name: Tag AMI for Marketplace (prod only)
        if: env.AMI_ID && env.STAGE == 'prod'
        env:
          VERSION: ${{ steps.get-version.outputs.version }}
          BUILD_REASON: ${{ inputs.reason }}
        run: |
          echo "üè∑Ô∏è Tagging AMI for AWS Marketplace distribution..."

          # Build tags array with latest release version
          BUILD_DATE=$(date -u +%Y-%m-%d)

          # Use bash array to properly handle values with spaces
          TAGS=(
            "Key=marketplace,Value=ready"
            "Key=version,Value=$VERSION"
            "Key=stage,Value=${{ env.STAGE }}"
            "Key=build_date,Value=$BUILD_DATE"
          )

          # Add reason tag if provided (safely via env var)
          if [ -n "$BUILD_REASON" ]; then
            TAGS+=("Key=build_reason,Value=$BUILD_REASON")
          fi

          # Apply tags (array expansion with proper quoting)
          aws ec2 create-tags \
            --resources "$AMI_ID" \
            --tags "${TAGS[@]}" \
            --region "${{ env.AWS_REGION }}"

          echo "‚úÖ AMI is ready for Marketplace submission"
          echo "üìù AMI is private and unencrypted (Marketplace requirement)"
          echo "üîó Next: Submit to AWS Marketplace Seller Console"
          echo "    https://aws.amazon.com/marketplace/management/products"

      - name: Update latest release with AMI details
        if: env.AMI_ID && steps.get-version.outputs.version != 'manual'
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.get-version.outputs.version }}
          BUILD_REASON: ${{ inputs.reason }}
        with:
          script: |
            const amiId = process.env.AMI_ID;
            const region = process.env.AWS_REGION;
            const stage = process.env.STAGE;
            const version = process.env.VERSION;
            const reason = process.env.BUILD_REASON || 'Manual AMI build';

            // Get latest release
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 1
            });

            if (releases.data.length === 0) {
              console.log('No releases found, skipping update');
              return;
            }

            const latestRelease = releases.data[0];

            const amiInfo = `

            ---

            ## üñ•Ô∏è AMI Build for ${version}

            **AMI ID:** \`${amiId}\`
            **Region:** \`${region}\`
            **Stage:** \`${stage}\`
            **Availability:** ${stage === 'prod' ? 'üè™ Ready for AWS Marketplace' : 'üîí Private (Dev)'}
            **Build Reason:** ${reason}
            **Build Date:** ${new Date().toISOString().split('T')[0]}

            **Launch URL:**
            https://console.aws.amazon.com/ec2/home?region=${region}#LaunchInstances:ami=${amiId}

            ### Quick Start Commands:
            \`\`\`bash
            # Launch instance with this AMI
            aws ec2 run-instances \\
              --image-id ${amiId} \\
              --instance-type t3.medium \\
              --key-name your-key-pair \\
              --security-group-ids sg-xxxxxxxxx \\
              --region ${region}

            # After instance is running, configure your node:
            ssh ubuntu@your-instance-ip
            sudo tn-node-configure
            \`\`\`
            `;

            // Update release body
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: latestRelease.id,
              body: (latestRelease.body || '') + amiInfo
            });

            console.log(`Updated release ${version} with AMI details`);

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: build-ami
    if: success()
    steps:
      - name: Success notification
        run: |
          echo "‚úÖ AMI build pipeline completed successfully!"
          echo "AMI is now available and ready for deployment."

  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: build-ami
    if: failure()
    steps:
      - name: Failure notification
        run: |
          echo "‚ùå AMI build pipeline failed!"
          echo "Please check the logs and AWS ImageBuilder console for details."
          exit 1
