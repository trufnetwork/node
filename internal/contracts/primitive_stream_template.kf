// This file is the template to be used by Data Providers to deploy their own contracts.
// A stream must conform to this same interface (read and permissions) to be eligible to officialization from our
// accepted System Streams.

database primitive_stream_db_name;

table primitive_events {
    date_value text unique notnull minlen(10) maxlen(10), // enforce yyyy-mm-dd format
    value int notnull,
    created_at int notnull, // based on blockheight

    #identifier_idx   primary(date_value, created_at)
}

table metadata {
    row_id      uuid    primary notnull,
    key         text    notnull,
    value_i     int,                 // integer type
    // TODO: uncomment to add this field in imminent kwil support
    // value_f     decimal,             // float type
    value_b     bool,                // boolean type
    value_s     text,                // string type
    value_ref   text,                // indexed string type
    created_at  int     notnull,     // block height
    disabled_at int,                 // block height

    #key_idx    index(key),
    #ref_idx    index(value_ref),
    #created_idx    index(created_at) // faster sorting
}

procedure is_initiated() private view returns (res bool) {
    // check if it was already initialized
    // for that we check if type is already provided
    for $row in SELECT * FROM metadata WHERE key = 'type' LIMIT 1 {
        return true;
    }

    return false;
}

procedure is_stream_owner($address text) private view returns (res bool) {
    for $row in SELECT * FROM metadata WHERE key = 'stream_owner' AND value_ref = $address LIMIT 1 {
        return true;
    }
    return false;
}

procedure stream_owner_only() private {
    if is_stream_owner(@caller) == false  {
        error('Stream owner only procedure');
    }
}

// init method prepares the contract with default values and permanent ones
procedure init() public owner {
    if is_initiated() {
        error('this contract was already initialized');
    }

    // TODO replace by intrinsic current_block value when kwil supports
    $current_block int := 1;

    // uuid's namespaces are any random generated uuid from https://www.uuidtools.com/v5
    // but each usage should be different to maintain determinism, so we reuse the previous result
    $current_uuid uuid := uuid_generate_v5('111bfa42-17a2-11ef-bf03-325096b39f47'::uuid, @txid);

    // type = primitive
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, key, value_s, created_at)
        VALUES ($current_uuid, 'type', 'primitive', $current_block);

    // stream_owner = @caller
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, key, value_ref, created_at)
        VALUES ($current_uuid, 'stream_owner', @caller, 1);

    // compose_visibility = 0 (public)
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, key, value_i, created_at)
        VALUES ($current_uuid, 'compose_visibility', 0, $current_block);

    // read_visibility = 0 (public)
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, key, value_i, created_at)
        VALUES ($current_uuid, 'read_visibility', 0, $current_block);

    $readonly_keys text[] := [
        'type',
        'stream_owner',
        'readonly_key'
    ];

    for $key in $readonly_keys {
        $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
        INSERT INTO metadata (row_id, key, value_s, created_at)
            VALUES ($current_uuid, 'readonly_key', $key, $current_block);
    }
}

// Note:    We're letting the user be the source of truth for which type a key should have.
//          To change that, we could initiate `key_type:<key>` key on metadata table, that could be used here
//          to enforce a type. However, this would force us to know every metadata key before deploying a contract
procedure insert_metadata(
    $key text,
    $value text,
    $val_type text
    // TODO: would be better to use value_x from args. However this doesn't work well for nullable inputs
    //  i.e. if we use a bool type we'll get an conversion error from Nil -> bool. And we don't want to force user to provide
    //  a value if nil is intended.
    ) public {

    $value_i int;
    $value_s text;
    $value_f text; // todo: decimal
    $value_b bool;
    $value_ref text;

    if $val_type == 'int' {
        $value_i := $value::int;
    } elseif $val_type == 'string' {
        $value_s := $value;
    } elseif $val_type == 'bool' {
        $value_b := $value::bool;
    } elseif $val_type == 'ref' {
        $value_ref := $value;
    } elseif $val_type == 'float' {
        // TODO add ::decimal
        $value_f := $value;
    } else {
        error(format('unknown type used "%s". valid types = "float" | "bool" | "int" | "ref" | "string"', $val_type));
    }

    stream_owner_only();

    if is_initiated() == false {
        error('contract must be initiated');
    }

    // check if it's read-only
    for $row in SELECT * FROM metadata WHERE key = 'readonly_key' AND value_s = $key LIMIT 1 {
        error('Cannot insert metadata for read-only key');
    }

    $uuid uuid := uuid_generate_v5('1361df5d-0230-47b3-b2c1-37950cf51fe9'::uuid, @txid);
    // TODO replace by context value when kwil supports
    $current_block int := 2;

    // insert data
    // TODO add value_f
    INSERT INTO metadata (row_id, key, value_i, value_s, value_b, value_ref, created_at)
        VALUES ($uuid, $key, $value_i, $value_s, $value_b, $value_ref, $current_block);
}

procedure get_metadata($key text, $only_latest bool) public view returns table(
        row_id uuid,
        value_i int,
        // TODO: uncomment when supported
        // value_f decimal,
        value_b bool,
        value_s text,
        value_ref text,
        created_at int
        ) {

        if $only_latest {
            return SELECT
                          row_id,
                          value_i,
                          value_b,
                          value_s,
                          value_ref,
                          created_at
            FROM metadata
            WHERE key = $key AND disabled_at IS NULL
            ORDER BY created_at DESC
            LIMIT 1;
        } else {
            return SELECT
                          row_id,
                          value_i,
                          value_b,
                          value_s,
                          value_ref,
                          created_at
             FROM metadata
             WHERE key = $key AND disabled_at IS NULL
             ORDER BY created_at DESC;
        }
}

procedure insert_record($date_value text, $value int) public {
    stream_owner_only();

    if is_initiated() == false {
        error('contract must be initiated');
    }

    // TODO replace by context value when kwil supports
    $current_block int := 3;

    // insert data
    INSERT INTO primitive_events (date_value, value, created_at)
        VALUES ($date_value, $value, $current_block);
}

// TODO: frozen_at is not used yet, but it will be used for lookback mechanism
// we can't do floating point division, but Truflation normally tracks
// index precision to the thousandth, so we will multiply by 1000 before performing integer division.
// Truflations calculation is ((current_primitive/first_primitive)*100).
// Therefore, we will alter the equation to ((current_primitive*100000)/first_primitive).
// This essentially gives us the same result, but with an extra 3 digits of precision.
// index := (currentPrimitive * 100000) / basePrimitive
procedure get_index($date_from text, $date_to text, $frozen_at text) private view returns table(
        date_value text,
        value int,
        index int
        ) {

    $dateFromValue text := '0000-00-00';
    if $date_from != '' {
        $dateFromValue := $date_from;
    }

    $dateToValue text := '9999-99-99';
    if $date_to != '' {
        $dateToValue := $date_to;
    }

    $baseValue int := get_base_value();
    for $row in SELECT date_value, value FROM primitive_events WHERE date_value >= $dateFromValue AND date_value <= $dateToValue ORDER BY date_value DESC, created_at DESC {
        // TODO: replace the following line by the commented one when kwil supports division
        // as per docs, it should be supported, but it's not working
        // return next $row.date_value, row.value * 100000 / $baseValue;
        return next $row.date_value, $row.value * 100000 * $baseValue;
    }
}

// get_base_value returns the first value of the primitive stream
procedure get_base_value() private view returns (value int) {
    for $row in SELECT value from primitive_events ORDER BY date_value ASC, created_at DESC LIMIT 1 {
        return $row.value;
    }

    // if no iterations, then there is no base value
    error('no base value found');
}
