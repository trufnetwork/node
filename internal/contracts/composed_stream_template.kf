// This file is the template to be used by Data Providers to deploy their own contracts.
// A stream must conform to this same interface (read and permissions) to be eligible to officialization from our
// accepted System Streams.

database composed_stream_db_name;

table taxonomies {
    child_stream_id     text    notnull,
    child_data_provider text    notnull,
    weight              decimal(10,3)   notnull,
    created_at          int     notnull,    //  block height
    disabled_at         int,                //  block height
    version             int     notnull,

    #identifier_idx   primary(version, child_data_provider, child_stream_id)
}

table metadata {
    row_id      uuid    primary notnull,
    metadata_key         text    notnull,
    value_i     int,                 // integer type
    value_f     decimal(10,3),       // float type
    value_b     bool,                // boolean type
    value_s     text,                // string type
    value_ref   text,                // indexed string type -- lowercase
    created_at  int     notnull,     // block height
    disabled_at int,                 // block height

    #key_idx        index(metadata_key),
    #ref_idx        index(value_ref),
    #created_idx    index(created_at) // faster sorting
}

foreign procedure ext_get_data($date_from text, $date_to text, $frozen_at text) returns table(
    date_value text,
    value decimal(10,3)
)

procedure stream_exists($data_provider text, $stream_id text) public view returns (result bool) {
    $dbid text := generate_dbid($data_provider, $stream_id);

    for $row in SELECT * FROM get_metadata('type', true, null) {
        return true;
    }

    return false;
}

procedure generate_dbid($data_provider text, $stream_id text) private view returns (result text) {
    $starts_with_0x bool := false;
    for $row in SELECT $data_provider LIKE '0x%' as a {
        $starts_with_0x := $row.a;
    }

    $data_provider_without_0x text;

    if $starts_with_0x == true {
        // TODO: once substring, left or right function is supported, we can remove this
        // for $row in SELECT substr($data_provider, 2) as a {
        //     $data_provider_without_0x := $row.a;
        // }
        error('data provider should not start with 0x');
    } else {
        $data_provider_without_0x := $data_provider;
    }

    $encoded_stream_id := encode(lower($stream_id)::blob, 'hex');

    for $row2 in SELECT
    'x' || encode(
        digest(
                decode($encoded_stream_id || $data_provider_without_0x, 'hex'),
                'sha224'
        ),
        'hex'
       ) AS dbid {
           return $row2.dbid;
       }

    error('could not generate dbid');
}

procedure get_date_list($date_from text, $date_to text, $frozen_at text) public view returns (
    date_value text[]
) {
    $weight_sum decimal(10,3) := 0::decimal(10,3);
    for $row in SELECT * FROM describe_taxonomies(true) {
        $weight_sum := $weight_sum + $row.weight;
    }

    if $weight_sum == 0::decimal(10,3) {
        error('No taxonomies found');
    }

    // get list date
    $date_list text[];
    for $row2 in SELECT * FROM describe_taxonomies(true) {
        $dbid text := generate_dbid($row2.child_data_provider, $row2.child_stream_id);
        for $row3 in SELECT * FROM ext_get_data[$dbid, 'get_record']($date_from, $date_to, $frozen_at) {
            $found bool := false;
            for $single_date in $date_list {
                if $single_date == $row3.date_value {
                    $found := true;
                    // TODO: would be better to use break or continue if supported here
                }
            }
            if $found == false {
                $date_list := array_append($date_list, $row3.date_value);
            }
        }
    }

    if array_length($date_list) == 0 {
        error('No data found on get_date_list');
    }

    return $date_list;
}

// It returns every record value for every date as its own
// row. e.g.:
// 2020-06-01, 100
// 2020-06-01, 140
// 2020-06-02, 103
// 2020-06-02, 143
procedure get_record_internal($date_from text, $date_to text, $frozen_at text) private view returns table(
    date_value text,
    value decimal(10,3)
) {
    $weight_sum decimal(10,3) := 0::decimal(10,3);
    for $row in SELECT * FROM describe_taxonomies(true) {
        $weight_sum := $weight_sum + $row.weight;
    }

    if $weight_sum == 0::decimal(10,3) {
        error('No taxonomies found');
    }

    // get list date, it would be easier if map type supported
    $date_list := get_date_list($date_from, $date_to, $frozen_at);

    if array_length($date_list) == 0 {
        error('No data found on date_list');
    }

    // find the first and last dates
    $start_date := $date_list[1];
    $end_date := $date_list[array_length($date_list)];

    for $row2 in SELECT * FROM describe_taxonomies(true) {
        $dbid text := generate_dbid($row2.child_data_provider, $row2.child_stream_id);
        for $row3 in SELECT * FROM ext_get_data[$dbid, 'get_record']($start_date, $end_date, $frozen_at) {

            // for each value, we will return it to the table with the calculations done

            return next $row3.date_value, $row3.value * $row2.weight::decimal(10,3) / $weight_sum::decimal(10,3);
        }
    }
}

// It returns every index value for every date as its own
// row. e.g.:
// 2020-06-01, 100
// 2020-06-01, 140
// 2020-06-02, 103
// 2020-06-02, 143
procedure get_index_internal($date_from text, $date_to text, $frozen_at text) private view returns table(
    date_value text,
    value decimal(10,3)
) {
    $weight_sum decimal(10,3) := 0::decimal(10,3);
    for $row in SELECT * FROM describe_taxonomies(true) {
        $weight_sum := $weight_sum + $row.weight;
    }

    if $weight_sum == 0::decimal(10,3) {
        error('No taxonomies found');
    }

    // get list date, it would be easier if map type supported
    $date_list := get_date_list($date_from, $date_to, $frozen_at);

    if array_length($date_list) == 0 {
        error('No data found on date_list');
    }

    // find the first and last dates
    $start_date := $date_list[1];
    $end_date := $date_list[array_length($date_list)];

    for $row2 in SELECT * FROM describe_taxonomies(true) {
        $dbid text := generate_dbid($row2.child_data_provider, $row2.child_stream_id);
        for $row3 in SELECT * FROM ext_get_data[$dbid, 'get_index']($start_date, $end_date, $frozen_at) {

            // for each value, we will return it to the table with the calculations done

            return next $row3.date_value, $row3.value * $row2.weight / $weight_sum;
        }
    }
}

// get_record retrieves the records for a specified date range
procedure get_record($date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value decimal(10,3)
) {
    // check if the stream is allowed to compose
    is_stream_allowed_to_compose();

    // here, we sum all of the values that were found by aggregating on the date_valie
    return select r.date_value as date_value, sum(r.value)::decimal(10,3) as value from get_record_internal($date_from, $date_to, $frozen_at) as r
    group by r.date_value;
}

// get_index retrieves the indexes for a specified date range
procedure get_index($date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value decimal(10,3)
) {
    // check if the stream is allowed to compose
    is_stream_allowed_to_compose();

    // here, we sum all of the indexes that were found by aggregating on the date_valie
    return select r.date_value as date_value, sum(r.value)::decimal(10,3) as value from get_index_internal($date_from, $date_to, $frozen_at) as r
    group by r.date_value;
}

procedure is_initiated() private view returns (result bool) {
    // check if it was already initialized
    // for that we check if type is already provided
    for $row in SELECT * FROM metadata WHERE metadata_key = 'type' LIMIT 1 {
        return true;
    }

    return false;
}

procedure is_stream_owner($wallet text) public view returns (result bool) {
    for $row in SELECT * FROM metadata WHERE metadata_key = 'stream_owner' AND value_ref = LOWER($wallet) LIMIT 1 {
        return true;
    }
    return false;
}

procedure is_wallet_allowed_to_read($wallet text) public view returns (value bool) {

    // if public, anyone can always read
    // If there's no visibility metadata, it's public.
    $visibility int := 0;
    for $v_row in SELECT * FROM get_metadata('read_visibility', true, null) {
        $visibility := $v_row.value_i;
    }

    if $visibility == 0 {
        return true;
    }

    // if it's the owner, it's permitted
    if is_stream_owner($wallet) {
        return true;
    }

    // if there's metadata allow_read_wallet -> <wallet>, then its permitted
    for $row in SELECT * FROM get_metadata('allow_read_wallet', false, $wallet) {
        return true;
    }

    return false;
}

procedure stream_owner_only() private {
    if is_stream_owner(@caller) == false  {
        error('Stream owner only procedure');
    }
}

// init method prepares the contract with default values and permanent ones
procedure init() public owner {
    if is_initiated() {
        error('this contract was already initialized');
    }

    $current_block int := @height;

    // uuid's namespaces are any random generated uuid from https://www.uuidtools.com/v5
    // but each usage should be different to maintain determinism, so we reuse the previous result
    $current_uuid uuid := uuid_generate_v5('41fea9f0-179f-11ef-8838-325096b39f47'::uuid, @txid);

    // type = composed
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_s, created_at)
        VALUES ($current_uuid, 'type', 'composed', $current_block);

    // stream_owner = @caller
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_ref, created_at)
        VALUES ($current_uuid, 'stream_owner', LOWER(@caller), 1);

    // compose_visibility = 0 (public)
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_i, created_at)
        VALUES ($current_uuid, 'compose_visibility', 0, $current_block);

    // read_visibility = 0 (public)
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_i, created_at)
        VALUES ($current_uuid, 'read_visibility', 0, $current_block);

    $readonly_keys text[] := [
        'type',
        'stream_owner',
        'readonly_key',
        'taxonomy_version'
    ];

    for $key in $readonly_keys {
        $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
        INSERT INTO metadata (row_id, metadata_key, value_s, created_at)
            VALUES ($current_uuid, 'readonly_key', $key, $current_block);
    }
}

// Note:    We're letting the user be the source of truth for which type a key should have.
//          To change that, we could initiate `key_type:<key>` key on metadata table, that could be used here
//          to enforce a type. However, this would force us to know every metadata key before deploying a contract
procedure insert_metadata(
    $key text,
    $value text,
    $val_type text
    // TODO: would be better to use value_x from args. However this doesn't work well for nullable inputs
    //  i.e. if we use a bool type we'll get an conversion error from Nil -> bool. And we don't want to force user to provide
    //  a value if nil is intended.
    ) public {

    $value_i int;
    $value_s text;
    $value_f decimal(10,3);
    $value_b bool;
    $value_ref text;

    if $val_type == 'int' {
        $value_i := $value::int;
    } elseif $val_type == 'string' {
        $value_s := $value;
    } elseif $val_type == 'bool' {
        $value_b := $value::bool;
    } elseif $val_type == 'ref' {
        $value_ref := $value;
    } elseif $val_type == 'float' {
        $value_f := $value::decimal(10,3);
    } else {
        error(format('unknown type used "%s". valid types = "float" | "bool" | "int" | "ref" | "string"', $val_type));
    }

    stream_owner_only();

    if is_initiated() == false {
        error('contract must be initiated');
    }

    // check if it's read-only
    for $row in SELECT * FROM metadata WHERE metadata_key = 'readonly_key' AND value_s = $key LIMIT 1 {
        error('Cannot insert metadata for read-only key');
    }

    $uuid uuid := uuid_generate_v5('1361df5d-0230-47b3-b2c1-37950cf51fe9'::uuid, @txid);
    $current_block int := @height;

    // insert data
    INSERT INTO metadata (row_id, metadata_key, value_i, value_f, value_s, value_b, value_ref, created_at)
        VALUES ($uuid, $key, $value_i, $value_f, $value_s, $value_b, LOWER($value_ref), $current_block);
}

// key: the metadata key to look for
// only_latest: if true, only return the latest version of the metadata
// ref: if provided, only return metadata with that ref
procedure get_metadata($key text, $only_latest bool, $ref text) public view returns table(
        row_id uuid,
        value_i int,
        value_f decimal(10,3),
        value_b bool,
        value_s text,
        value_ref text,
        created_at int
        ) {

        if $only_latest == true {
            if $ref is distinct from null {
                for $row in SELECT
                              row_id,
                              value_ref,
                              created_at
                FROM metadata
                WHERE metadata_key = $key AND disabled_at IS NULL AND value_ref = LOWER($ref)
                ORDER BY created_at DESC
                LIMIT 1 {
                    return next $row.row_id, null, null, null, null, $row.value_ref, $row.created_at;
                }
            } else {
                return SELECT
                              row_id,
                              value_i,
                              value_f,
                              value_b,
                              value_s,
                              value_ref,
                              created_at
                FROM metadata
                WHERE metadata_key = $key AND disabled_at IS NULL
                ORDER BY created_at DESC
                LIMIT 1;
            }
        } else {
           // SHOULD BE THE EXACT CODE AS ABOVE, BUT WITHOUT LIMIT
           if $ref is distinct from null {
               for $row2 in SELECT
                             row_id,
                             value_ref,
                             created_at
               FROM metadata
               WHERE metadata_key = $key AND disabled_at IS NULL AND value_ref = LOWER($ref)
               ORDER BY created_at DESC {
                   return next $row2.row_id, null, null, null, null, $row2.value_ref, $row2.created_at;
               }
           } else {
               return SELECT
                             row_id,
                             value_i,
                             value_f,
                             value_b,
                             value_s,
                             value_ref,
                             created_at
               FROM metadata
               WHERE metadata_key = $key AND disabled_at IS NULL
               ORDER BY created_at DESC;
           }
        }
}

procedure disable_metadata($row_id uuid) public {
    stream_owner_only();

    $current_block int := @height;

    $found bool := false;

    // Check if the metadata is not read-only
    for $metadata_row in
    SELECT metadata_key
    FROM metadata
    WHERE row_id = $row_id AND disabled_at IS NULL
    LIMIT 1 {
        $found := true;
        $row_key text := $metadata_row.metadata_key;

        for $readonly_row in SELECT row_id FROM metadata WHERE metadata_key = 'readonly_key' AND value_s = $row_key LIMIT 1 {
            error('Cannot disable read-only metadata');
        }

        UPDATE metadata SET disabled_at = $current_block
        WHERE row_id = $row_id;
    }

    if $found == false {
        error('metadata record not found');
    }
}

procedure transfer_stream_ownership($new_owner text) public {
    stream_owner_only();

    // fail if not a valid address
    check_eth_address($new_owner);

    UPDATE metadata SET value_ref = LOWER($new_owner)
    WHERE metadata_key = 'stream_owner';
}

procedure check_eth_address($address text) private {
    // TODO better check when kwil supports regexp and {}[] inside strings
    // regex: ^0x[0-9a-fA-F]{40}$
    // for $row in SELECT regexp_match($address, '^0x[0-9a-fA-F]{40}$') {
    //     return true;
    // }

    if (length($address) != 42) {
        error('invalid address length');
    }

    // check if starts with 0x
    for $row in SELECT $address LIKE '0x%' as a {
        if $row.a == false {
            error('address does not start with 0x');
        }
    }
}

procedure get_current_version($show_disabled bool) private view returns (result int) {
    if $show_disabled == false {
         for $row in SELECT version FROM taxonomies WHERE disabled_at IS NULL ORDER BY version DESC LIMIT 1 {
             return $row.version;
         }
    } else {
        for $row2 in SELECT version FROM taxonomies ORDER BY version DESC LIMIT 1 {
            return $row2.version;
        }
    }

    return 0;
}


// NOTE we won't use this signature jsonb is not supported
// procedure set_taxonomy($payload text) public {
//     stream_owner_only();
//     $next_version int := get_current_version() + 1;
//     $block_height int := 2;
//     $current_uuid uuid := uuid_generate_v5('e92064da-19c5-11ef-9bc0-325096b39f47'::uuid, @txid);
//    for $row in SELECT
//            elem->>'stream_id' as stream_id,
//            elem->>'data_provider' as data_provider,
//            elem->>'weight' as weight
//        FROM jsonb_array_elements($payload::jsonb) as elem {
//         $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
//         INSERT INTO taxonomy ( child_stream_id, child_stream_id, weight, created_at, version)
//             VALUES ($row.stream_id, $row.data_provider, $row.weight::int, $block_height, $next_version);
//     }
// }

// set_taxonomy is a batch insert that
// - gets an array of values for each properties, zipping them as needed
// - increases the version
// - adds taxonomy records in batch
procedure set_taxonomy($data_providers text[], $stream_ids text[], $weights decimal(10,3)[]) public {
    stream_owner_only();

    $next_version int := get_current_version(true) + 1;
    $block_height int := 2;
    $current_uuid uuid := uuid_generate_v5('e92064da-19c5-11ef-9bc0-325096b39f47'::uuid, @txid);

    $length int := array_length($data_providers);

    // check lengths
    if $length != array_length($stream_ids) {
        error('data_providers and stream_ids must have the same length');
    }
    if $length != array_length($weights) {
        error('data_providers and weights must have the same length');
    }

    for $i in 1..$length {
        $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
        INSERT INTO taxonomies (child_stream_id, child_data_provider, weight, created_at, version)
            VALUES ($stream_ids[$i], $data_providers[$i], $weights[$i], $block_height, $next_version);
    }
}

procedure describe_taxonomies($latest_version bool) public view returns table(
        child_stream_id text,
        child_data_provider text,
        weight decimal(10,3),
        created_at int,
        version int
        ) {

        if $latest_version == true {
            // just the latest enabled version should be returned
            $current_version int := get_current_version(false);
            for $row in SELECT
                child_stream_id,
                child_data_provider,
                weight,
                created_at,
                version
            FROM taxonomies
            WHERE version = $current_version AND disabled_at IS NULL
            ORDER BY created_at DESC {
                return next $row.child_stream_id, $row.child_data_provider, $row.weight, $row.created_at, $row.version;
            }
        } else {
            for $row2 in SELECT
                child_stream_id,
                child_data_provider,
                weight,
                created_at,
                version
            FROM taxonomies
            WHERE disabled_at IS NULL
            ORDER BY version DESC {
                return next $row2.child_stream_id, $row2.child_data_provider, $row2.weight, $row2.created_at, $row2.version;
            }
        }
}

procedure disable_taxonomy($version int) public {
    stream_owner_only();

    $current_block int := @height;

    $found bool := false;

    // Check if the taxonomies with the given version exist and disable them
    for $row in SELECT child_stream_id FROM taxonomies WHERE version = $version AND disabled_at IS NULL {
        $found := true;
        UPDATE taxonomies SET disabled_at = $current_block
        WHERE version = $version AND disabled_at IS NULL;
    }

    if $found == false {
        error('No taxonomies found for the given version');
    }
}

procedure is_stream_allowed_to_compose() public view returns (value bool) {
    // if public, anyone can always read
    // If there's no visibility metadata, it's public.
    $visibility int := 0;
    for $v_row in SELECT * FROM get_metadata('compose_visibility', true, null) {
        $visibility := $v_row.value_i;
    }

    if $visibility == 0 {
        return true;
    }

    // if there's metadata allow_compose_stream -> <foreign_caller>, then its permitted
    for $row in SELECT * FROM get_metadata('allow_compose_stream', true, @foreign_caller) LIMIT 1 {
        return true;
    }

    error('Stream not allowed to compose');
}