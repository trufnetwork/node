// This file is the template to be used by Data Providers to deploy their own contracts.
// A stream must conform to this same interface (read and permissions) to be eligible to officialization from our
// accepted System Streams.

database composed_stream_db_name;

table taxonomies {
    child_stream_id     text    notnull,
    child_data_provider text    notnull,
    weight              int     notnull,
    created_at          int     notnull,    //  block height
    disabled_at         int,                //  block height
    version             int     notnull,

    #identifier_idx   primary(version, child_data_provider, child_stream_id)
}

table metadata {
    row_id      uuid    primary notnull,
    metadata_key         text    notnull,
    value_i     int,                 // integer type
    // TODO: uncomment to add this field in imminent kwil support
    // value_f     decimal,             // float type
    value_b     bool,                // boolean type
    value_s     text,                // string type
    value_ref   text,                // indexed string type -- lowercase
    created_at  int     notnull,     // block height
    disabled_at int,                 // block height

    #key_idx        index(metadata_key),
    #ref_idx        index(value_ref),
    #created_idx    index(created_at) // faster sorting
}

foreign procedure ext_get_data($date_from text, $date_to text, $frozen_at text) returns table(
    date_value text,
    value int
)

procedure stream_exists($data_provider text, $stream_id text) public view returns (result bool) {
    $dbid text := generate_dbid($data_provider, $stream_id);

    for $row in SELECT * FROM get_metadata('type', true) {
        return true;
    }

    return false;
}

procedure generate_dbid($data_provider text, $stream_id text) private view returns (result text) {
    $starts_with_0x bool := false;
    for $row in SELECT $data_provider LIKE '0x%' as a {
        $starts_with_0x := $row.a;
    }

    $data_provider_without_0x text;

    if $starts_with_0x == true {
        // TODO: once substring, left or right function is supported, we can remove this
        // for $row in SELECT substr($data_provider, 2) as a {
        //     $data_provider_without_0x := $row.a;
        // }
        error('data provider should not start with 0x');
    } else {
        $data_provider_without_0x := $data_provider;
    }

    $encoded_stream_id := encode(lower($stream_id)::blob, 'hex');

    for $row2 in SELECT
    'x' || encode(
        digest(
                decode($encoded_stream_id || $data_provider_without_0x, 'hex'),
                'sha224'
        ),
        'hex'
       ) AS dbid {
           return $row2.dbid;
       }

    error('could not generate dbid');
}

procedure get_date_list($date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text
) {
    $weight_sum int := 0;
    for $row in SELECT * FROM describe_taxonomies(true) {
        $weight_sum := $weight_sum + $row.weight;
    }

    if $weight_sum == 0 {
        error('No taxonomies found');
    }

    // get list date
    $date_list text[];
    for $row2 in SELECT * FROM describe_taxonomies(true) {
        // TODO: need to fix this generate_dbid, for now we're using a fixed value
        //$dbid text := generate_dbid($row2.child_data_provider, $row2.child_stream_id);
        $dbid text := 'xd74c3f5812976a7f5982e9b63f8352dc5c3b12a71abc29f0578b2672';
        $dbid2 text := 'x34ba7edd495810995b921b525666c7b0d60f18a2249d79f818a43e66';
        for $row3 in SELECT * FROM ext_get_data[$dbid, 'get_record']($date_from, $date_to, $frozen_at) {
            $found bool := false;
            for $single_date in $date_list {
                if $single_date == $row3.date_value {
                    $found := true;
                    // TODO: would be better to use break or continue if supported here
                }
            }
            if $found == false {
                $date_list := array_append($date_list, $row3.date_value);
            }
        }
        for $row4 in SELECT * FROM ext_get_data[$dbid2, 'get_record']($date_from, $date_to, $frozen_at) {
                    $found bool := false;
                    for $single_date2 in $date_list {
                        if $single_date2 == $row4.date_value {
                            $found := true;
                            // TODO: would be better to use break or continue if supported here
                        }
                    }
                    if $found == false {
                        $date_list := array_append($date_list, $row3.date_value);
                    }
                }
    }

    if array_length($date_list) == 0 {
        error('No data found on get_date_list');
    }

    for $date in $date_list {
        return next $date;
    }
}

// TODO: currently two dimensional array and map type is not supported
// so we're using a workaround to get the data from the external contract
// this results in a lot of queries, which is not ideal
// once the map or two dimensional type is supported, we can get all the data in one query
// alternatively, if there is a chance we can build a query from a text inside a variable
// like in Golang's `fmt.Sprintf` or something like `query builder` GORM, that's would suffice
procedure get_record($date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value int
) {
    $weight_sum int := 0;
    for $row in SELECT * FROM describe_taxonomies(true) {
        $weight_sum := $weight_sum + $row.weight;
    }

    if $weight_sum == 0 {
        error('No taxonomies found');
    }

    // get list date, it would be easier if map type supported
    $date_list text[];
    for $row_date in SELECT * FROM get_date_list($date_from, $date_to, $frozen_at) {
        $date_list := array_append($date_list, $row_date.date_value);
    }

    if array_length($date_list) == 0 {
        error('No data found on date_list');
    }

    for $single_date in $date_list {
        $value_sum int := 0;
        for $row2 in SELECT * FROM describe_taxonomies(true) {
            $dbid text := generate_dbid($row2.child_data_provider, $row2.child_stream_id);
            for $row3 in SELECT * FROM ext_get_data[$dbid, 'get_record']($single_date, $single_date, $frozen_at) {
                $value_sum := $value_sum + ($row3.value * $row2.weight * 1000 / $weight_sum);
            }
            if $value_sum == 0 {
                error('No data found on ext_get_data');
            }
        }
        return next $single_date, $value_sum;
    }
}

procedure get_index($date_from text, $date_to text, $frozen_at text) public view returns table(
    date_value text,
    value int
) {
    $weight_sum int := 0;
    for $row in SELECT * FROM describe_taxonomies(true) {
        $weight_sum := $weight_sum + $row.weight;
    }

    if $weight_sum == 0 {
        error('No taxonomies found');
    }

    // get list date, it would be cleaner if map type supported
    $date_list text[];
    for $row_date in SELECT * FROM get_date_list($date_from, $date_to, $frozen_at) {
        $date_list := array_append($date_list, $row_date.date_value);
    }

    if array_length($date_list) == 0 {
        error('No data found');
    }

    for $single_date in $date_list {
        $value_sum int := 0;
        for $row2 in SELECT * FROM describe_taxonomies(true) {
            $dbid text := generate_dbid($row2.child_data_provider, $row2.child_stream_id);
            for $row3 in SELECT * FROM ext_get_data[$dbid, 'get_index']($single_date, $single_date, $frozen_at) {
                $value_sum := $value_sum + ($row3.value * $row2.weight / $weight_sum);
            }
            if $value_sum == 0 {
                error('No data found');
            }
        }
        return next $single_date, $value_sum;
    }
}

procedure is_initiated() private view returns (result bool) {
    // check if it was already initialized
    // for that we check if type is already provided
    for $row in SELECT * FROM metadata WHERE metadata_key = 'type' LIMIT 1 {
        return true;
    }

    return false;
}

procedure is_stream_owner($wallet text) public view returns (result bool) {
    for $row in SELECT * FROM metadata WHERE metadata_key = 'stream_owner' AND value_ref = LOWER($wallet) LIMIT 1 {
        return true;
    }
    return false;
}

procedure is_wallet_allowed_to_read($wallet text) public view returns (value bool) {

    // if public, anyone can always read
    // If there's no visibility metadata, it's public.
    $visibility int := 0;
    for $v_row in SELECT * FROM get_metadata('read_visibility', true) {
        $visibility := $v_row.value_i;
    }

    if $visibility == 0 {
        return true;
    }

    // if it's the owner, it's permitted
    if is_stream_owner($wallet) {
        return true;
    }

    // if there's metadata allow_read_wallet -> <wallet>, then its permitted
    for $row in SELECT * FROM metadata WHERE metadata_key = 'allow_read_wallet' AND value_ref = LOWER($wallet) AND disabled_at IS NULL LIMIT 1 {
        return true;
    }

    return false;
}

procedure stream_owner_only() private {
    if is_stream_owner(@caller) == false  {
        error('Stream owner only procedure');
    }
}

// init method prepares the contract with default values and permanent ones
procedure init() public owner {
    if is_initiated() {
        error('this contract was already initialized');
    }

    // TODO replace by intrinsic current_block value when kwil supports
    $current_block int := 1;

    // uuid's namespaces are any random generated uuid from https://www.uuidtools.com/v5
    // but each usage should be different to maintain determinism, so we reuse the previous result
    $current_uuid uuid := uuid_generate_v5('41fea9f0-179f-11ef-8838-325096b39f47'::uuid, @txid);

    // type = composed
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_s, created_at)
        VALUES ($current_uuid, 'type', 'composed', $current_block);

    // stream_owner = @caller
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_ref, created_at)
        VALUES ($current_uuid, 'stream_owner', LOWER(@caller), 1);

    // compose_visibility = 0 (public)
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_i, created_at)
        VALUES ($current_uuid, 'compose_visibility', 0, $current_block);

    // read_visibility = 0 (public)
    $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
    INSERT INTO metadata (row_id, metadata_key, value_i, created_at)
        VALUES ($current_uuid, 'read_visibility', 0, $current_block);

    $readonly_keys text[] := [
        'type',
        'stream_owner',
        'readonly_key',
        'taxonomy_version'
    ];

    for $key in $readonly_keys {
        $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
        INSERT INTO metadata (row_id, metadata_key, value_s, created_at)
            VALUES ($current_uuid, 'readonly_key', $key, $current_block);
    }
}

// Note:    We're letting the user be the source of truth for which type a key should have.
//          To change that, we could initiate `key_type:<key>` key on metadata table, that could be used here
//          to enforce a type. However, this would force us to know every metadata key before deploying a contract
procedure insert_metadata(
    $key text,
    $value text,
    $val_type text
    // TODO: would be better to use value_x from args. However this doesn't work well for nullable inputs
    //  i.e. if we use a bool type we'll get an conversion error from Nil -> bool. And we don't want to force user to provide
    //  a value if nil is intended.
    ) public {

    $value_i int;
    $value_s text;
    $value_f text; // todo: decimal
    $value_b bool;
    $value_ref text;

    if $val_type == 'int' {
        $value_i := $value::int;
    } elseif $val_type == 'string' {
        $value_s := $value;
    } elseif $val_type == 'bool' {
        $value_b := $value::bool;
    } elseif $val_type == 'ref' {
        $value_ref := $value;
    } elseif $val_type == 'float' {
        // TODO add ::decimal
        $value_f := $value;
    } else {
        error(format('unknown type used "%s". valid types = "float" | "bool" | "int" | "ref" | "string"', $val_type));
    }

    stream_owner_only();

    if is_initiated() == false {
        error('contract must be initiated');
    }

    // check if it's read-only
    for $row in SELECT * FROM metadata WHERE metadata_key = 'readonly_key' AND value_s = $key LIMIT 1 {
        error('Cannot insert metadata for read-only key');
    }

    $uuid uuid := uuid_generate_v5('1361df5d-0230-47b3-b2c1-37950cf51fe9'::uuid, @txid);
    // TODO replace by context value when kwil supports
    $current_block int := 2;

    // insert data
    // TODO add value_f
    INSERT INTO metadata (row_id, metadata_key, value_i, value_s, value_b, value_ref, created_at)
        VALUES ($uuid, $key, $value_i, $value_s, $value_b, LOWER($value_ref), $current_block);
}

procedure get_metadata($key text, $only_latest bool) public view returns table(
        row_id uuid,
        value_i int,
        // TODO: uncomment when supported
        // value_f decimal,
        value_b bool,
        value_s text,
        value_ref text,
        created_at int
        ) {

        if $only_latest {
            return SELECT
                          row_id,
                          value_i,
                          value_b,
                          value_s,
                          value_ref,
                          created_at
            FROM metadata
            WHERE metadata_key = $key AND disabled_at IS NULL
            ORDER BY created_at DESC
            LIMIT 1;
        } else {
            return SELECT
                          row_id,
                          value_i,
                          value_b,
                          value_s,
                          value_ref,
                          created_at
             FROM metadata
             WHERE metadata_key = $key AND disabled_at IS NULL
             ORDER BY created_at DESC;
        }
}

procedure disable_metadata($row_id uuid) public {
    stream_owner_only();

    // TODO when kwil enables current block from context
    $current_block int := 3;

    $found bool := false;

    // Check if the metadata is not read-only
    for $metadata_row in
    SELECT metadata_key
    FROM metadata
    WHERE row_id = $row_id AND disabled_at IS NULL
    LIMIT 1 {
        $found := true;
        $row_key text := $metadata_row.metadata_key;

        for $readonly_row in SELECT row_id FROM metadata WHERE metadata_key = 'readonly_key' AND value_s = $row_key LIMIT 1 {
            error('Cannot disable read-only metadata');
        }

        UPDATE metadata SET disabled_at = $current_block
        WHERE row_id = $row_id;
    }

    if $found == false {
        error('metadata record not found');
    }
}

procedure transfer_stream_ownership($new_owner text) public {
    stream_owner_only();

    // fail if not a valid address
    check_eth_address($new_owner);

    UPDATE metadata SET value_ref = LOWER($new_owner)
    WHERE metadata_key = 'stream_owner';
}

procedure check_eth_address($address text) private {
    // TODO better check when kwil supports regexp and {}[] inside strings
    // regex: ^0x[0-9a-fA-F]{40}$
    // for $row in SELECT regexp_match($address, '^0x[0-9a-fA-F]{40}$') {
    //     return true;
    // }

    if (length($address) != 42) {
        error('invalid address length');
    }

    // check if starts with 0x
    for $row in SELECT $address LIKE '0x%' as a {
        if $row.a == false {
            error('address does not start with 0x');
        }
    }
}

procedure get_current_version($show_disabled bool) private view returns (result int) {
    if $show_disabled == false {
         for $row in SELECT version FROM taxonomies WHERE disabled_at IS NULL ORDER BY version DESC LIMIT 1 {
             return $row.version;
         }
    } else {
        for $row2 in SELECT version FROM taxonomies ORDER BY version DESC LIMIT 1 {
            return $row2.version;
        }
    }

    return 0;
}


// NOTE we won't use this signature jsonb is not supported
// procedure set_taxonomy($payload text) public {
//     stream_owner_only();
//     $next_version int := get_current_version() + 1;
//     $block_height int := 2;
//     $current_uuid uuid := uuid_generate_v5('e92064da-19c5-11ef-9bc0-325096b39f47'::uuid, @txid);
//    for $row in SELECT
//            elem->>'stream_id' as stream_id,
//            elem->>'data_provider' as data_provider,
//            elem->>'weight' as weight
//        FROM jsonb_array_elements($payload::jsonb) as elem {
//         $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
//         INSERT INTO taxonomy ( child_stream_id, child_stream_id, weight, created_at, version)
//             VALUES ($row.stream_id, $row.data_provider, $row.weight::int, $block_height, $next_version);
//     }
// }

// set_taxonomy is a batch insert that
// - gets an array of values for each properties, zipping them as needed
// - increases the version
// - adds taxonomy records in batch
procedure set_taxonomy($data_providers text[], $stream_ids text[], $weights text[]) public {
    stream_owner_only();

    $next_version int := get_current_version(true) + 1;
    $block_height int := 2;
    $current_uuid uuid := uuid_generate_v5('e92064da-19c5-11ef-9bc0-325096b39f47'::uuid, @txid);

    $length int := array_length($data_providers);

    // check lengths
    if $length != array_length($stream_ids) {
        error('data_providers and stream_ids must have the same length');
    }
    if $length != array_length($weights) {
        error('data_providers and weights must have the same length');
    }

    for $i in 1..$length {
        $current_uuid :=  uuid_generate_v5($current_uuid, @txid);
        INSERT INTO taxonomies (child_stream_id, child_data_provider, weight, created_at, version)
            VALUES ($stream_ids[$i], $data_providers[$i], $weights[$i]::int, $block_height, $next_version);
    }
}

procedure describe_taxonomies($latest_version bool) public view returns table(
        child_stream_id text,
        child_data_provider text,
        weight int,
        created_at int,
        version int
        ) {

        if $latest_version == true {
            // just the latest enabled version should be returned
            $current_version int := get_current_version(false);
            for $row in SELECT
                child_stream_id,
                child_data_provider,
                weight,
                created_at,
                version
            FROM taxonomies
            WHERE version = $current_version AND disabled_at IS NULL
            ORDER BY created_at DESC {
                return next $row.child_stream_id, $row.child_data_provider, $row.weight, $row.created_at, $row.version;
            }
        } else {
            for $row2 in SELECT
                child_stream_id,
                child_data_provider,
                weight,
                created_at,
                version
            FROM taxonomies
            WHERE disabled_at IS NULL
            ORDER BY version DESC {
                return next $row2.child_stream_id, $row2.child_data_provider, $row2.weight, $row2.created_at, $row2.version;
            }
        }
}

procedure disable_taxonomy($version int) public {
    stream_owner_only();

    // TODO when kwil enables current block from context
    $current_block int := 4;

    $found bool := false;

    // Check if the taxonomies with the given version exist and disable them
    for $row in SELECT child_stream_id FROM taxonomies WHERE version = $version AND disabled_at IS NULL {
        $found := true;
        UPDATE taxonomies SET disabled_at = $current_block
        WHERE version = $version AND disabled_at IS NULL;
    }

    if $found == false {
        error('No taxonomies found for the given version');
    }
}
