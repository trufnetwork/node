package kwil_network

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"

	"github.com/aws/aws-cdk-go/awscdk/v2"
	"github.com/aws/constructs-go/constructs/v10"
	"github.com/aws/jsii-runtime-go"
	"github.com/trufnetwork/node/infra/config"
	"github.com/trufnetwork/node/infra/lib/kwil-network/peer"
	"go.uber.org/zap"
)

type GenerateGenesisFileInput struct {
	PeerConnections []peer.TNPeer
	ChainId         string
	DbOwner         string
	NodeKeys        []NodeKeys
}

// GenerateGenesisFile generates a genesis file, with all peers in the network as validators
// It returns the path of the generated genesis file
// it does that by executing
//   - create temp dir
//   - generate complete config
//     kwild setup init --chain-id <chainId> --root <tmp-dir>
//   - reading the genesis file inside it at <tmp-dir>/genesis.json
//   - modifying the genesis file to include all peers as validators

func GenerateGenesisFile(scope constructs.Construct, input GenerateGenesisFileInput) string {
	// Create a temporary directory for the configuration
	tempDir := awscdk.FileSystem_Mkdtemp(jsii.String("genesis-config"))
	tempDir = jsii.String(*tempDir + "/config")

	if len(input.PeerConnections) == 0 {
		panic(fmt.Sprintf("PeerConnections list cannot be empty when generating genesis with validators"))
	}

	// Prepare Validators list
	var validators []Validator
	for i, p := range input.PeerConnections {
		validators = append(validators, Validator{
			Pubkey: p.NodeHexAddress,
			Type:   input.NodeKeys[i].KeyType,
			Power:  1,
		})
	}
	// Generate configuration using kwild CLI
	// kwild setup init --chain-id <chainId> --root <tmp-dir>
	envVarsMain := config.GetEnvironmentVariables[config.MainEnvironmentVariables](scope)
	cmd := exec.Command(envVarsMain.KwildCliPath, "setup", "init",
		"--chain-id", input.ChainId,
		"--root", *tempDir,
		"--db-owner", input.DbOwner,
	)

	// Run the kwild setup command, capturing stdout/stderr
	output, err := cmd.CombinedOutput()
	if err != nil {
		// Include the captured output for easier debugging
		zap.L().Panic("Failed to generate genesis file", zap.Error(err), zap.String("output", string(output)))
	}

	// Read the genesis file
	genesisFile := *tempDir + "/genesis.json"
	genesisFileContent, err := os.ReadFile(genesisFile)
	if err != nil {
		zap.L().Panic("Failed to read genesis file", zap.Error(err))
	}

	// Modify the genesis file to include all peers as validators
	genesis := make(map[string]interface{})
	err = json.Unmarshal(genesisFileContent, &genesis)
	if err != nil {
		panic(fmt.Sprintf("failed to unmarshal genesis file: %v", err))
	}

	// 1. Replace Validators
	genesis["validators"] = validators

	// 2. Update Leader to be the first validator
	if len(validators) > 0 {
		firstValidator := validators[0] // Assumes Validator struct has Pubkey and Type
		genesis["leader"] = map[string]interface{}{
			"key":  firstValidator.Pubkey,
			"type": firstValidator.Type,
		}
	} else {
		// Handle the case where no validators are provided, though the earlier panic should prevent this.
		// Maybe remove the leader key or keep the default?
		// For now, we'll keep the default leader generated by `kwild setup init`.
		zap.L().Warn("No validators provided, keeping default leader in genesis.json")
	}

	// Marshal the modified genesis data back to bytes
	genesisBytes, err := json.MarshalIndent(genesis, "", "  ") // Use MarshalIndent for readability
	if err != nil {
		panic(fmt.Sprintf("failed to marshal modified genesis file: %v", err))
	}

	// Write the modified bytes back to the genesis file
	err = os.WriteFile(genesisFile, genesisBytes, 0644)
	if err != nil {
		panic(fmt.Sprintf("failed to write modified genesis file: %v", err))
	}

	return genesisFile
}

// Validator represents a validator in the network as expected in genesis.json
// { "pubkey": "...", "type": "secp256k1", "power": 1 }
type Validator struct {
	Pubkey string `json:"pubkey"`
	Type   string `json:"type"`
	Power  int    `json:"power"`
}
